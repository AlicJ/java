package sort;

import static org.junit.Assert.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Scanner;

import org.apache.commons.lang3.time.StopWatch;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class SortTest {
	private Word[][] inputWord = {new Word[16], new Word[256], new Word[4096]};
	double startTime;
	double endTime;
	double runTime;
	StopWatch sw;
	String[] output = {"", "", ""};	
	
	public boolean isEmpty(Word[] x) {
		for (int i=0; i<x.length; i++) {
			if (x[i] == null) return true;
		}
		return false;
	}

	@BeforeClass
	public static void setup() throws FileNotFoundException {
		// read input file and convert everything to array of Word
		Scanner input = new Scanner(new File("data/a2_in.txt"));
		
		for (int i=0; i<3; i++) {
			// read a line
			String line = input.nextLine();
			String[] data = line.split(",");
//			System.out.println("i=" + i);
			for(int j=0; j<data.length; j++) {
				if (j%2 != 0) {
					// odd number element -> ranking
					// get the previous element, the word
					String str = data[j-1].substring(1);
					// get rid of "}" at the end of the ranking
					String rank = data[j];
					rank = rank.substring(0, rank.length()-1);
					// and construct a Word with the previous element
					Word word = new Word(str, Integer.parseInt(rank));
//					System.out.println(word);
//					System.out.println("j=" + j);
					inputWord[i][(int) Math.floor(j/2)] = word;
				}
			}
			// initialize output array
			output[i] += inputWord[i].length;
//			System.out.println(Arrays.toString(wordInput[i]));
//			System.out.println(isEmpty(wordInput[i]));
		}
	}
	
	@Test
	public void testSortInsert() {
		sw = new StopWatch();
		sw.start();
		System.out.println("Insertion sort");
		for (int i=0; i<3; i++) {
			startTime = sw.getTime();
			Insertion.sortInsert(inputWord[i]);
			endTime = sw.getTime();
			runTime = (endTime - startTime) / 1000;
			output[i] += "sorting method," + runTime;
			// System.out.println(Insertion.isSorted(inputWord[i]));
		}
		sw.stop();
		System.out.println();
	}
	
	@Test
	public void testInsertComparable() {
		sw = new StopWatch();
		sw.start();
		System.out.println("Insertion sort comparable");
		for (int i=0; i<3; i++) {
			startTime = sw.getTime();
			Insertion.sortComparable(inputWord[i]);
			endTime = sw.getTime();
			runTime = (endTime - startTime) / 1000;
			output[i] += "sorting method," + runTime;
			// System.out.println(Insertion.isSorted(inputWord[i]));
		}
		sw.stop();
		System.out.println();
	}
	
	@Test
	public void testInsertBinary() {
		sw = new StopWatch();
		sw.start();
		System.out.println("Insertion sort binary");
		for (int i=0; i<3; i++) {
			startTime = sw.getTime();
			Insertion.sortBinary(inputWord[i]);
			endTime = sw.getTime();
			runTime = (endTime - startTime) / 1000;
			output[i] += "sorting method," + runTime;
			// System.out.println(Insertion.isSorted(inputWord[i]));
		}
		sw.stop();
		System.out.println();
	}
	
	@Test
	public void testMerge() {
		sw = new StopWatch();
		sw.start();
		System.out.println("Merge sort");
		for (int i=0; i<3; i++) {
			startTime = sw.getTime();
			Merge.sortMerge(inputWord[i]);
			endTime = sw.getTime();
			runTime = (endTime - startTime) / 1000;
			output[i] += "sorting method," + runTime;
			// System.out.println(Merge.isSorted(inputWord[i]));
		}
		sw.stop();
		System.out.println();
	}
	
	@Test
	public void testHeapSort() {
		sw = new StopWatch();
		sw.start();
		System.out.println("Heap sort");
		for (int i=0; i<3; i++) {
			startTime = sw.getTime();
			Heap.sortHeap(inputWord[i]);
			endTime = sw.getTime();
			runTime = (endTime - startTime) / 1000;
			output[i] += "sorting method," + runTime;
			// System.out.println(Heap.isSorted(inputWord[i]));
		}
		sw.stop();
		System.out.println();
	}
	
	@AfterClass
	public static void output() {
		System.out.println(Arrays.toString(output));
	}

}
